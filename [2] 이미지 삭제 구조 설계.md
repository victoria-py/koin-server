# [2] 이미지 삭제 구조 설계

# 예상 플로우

1. mcard 생성 시, 카드의 메타데이터에 `must_be_deleted_files` 을 배열로 받음
2. transaction_processor
    - Task를 받아서 **transaction-db**에 해당 트랜잭션 상태 업데이트 (state = DELETE)
    - **mcards-db**에서 카드 데이터 제거
    - DB에서 데이터가 삭제되지 않으면,, 골치아프니까 삭제된 후 queue에 인큐
    - mcard meta 데이터 중 `must_be_deleted_files`의 요소를  `file_management_queue`에 Enqueue
        - file_remover가 해당 url 별로 작업을 수행

    ---

# 코드플로우

## 1. ***Sync인 경우***

```
"""
MCard 삭제는 명시적으로 delete_mcard 호출 전에 mcard의 상태를 deleted로 변경해야 한다.
그래야, 사용자에게 삭제 프로세스 중인 mcard 임을 알려줄 수 있다.
"""
```

카드 소유주 체크하며 permission 체크

### MCard가 ERC인 경우

- Web3Wrapper 프로토콜 기반으로 카드 삭제 요청
- `Tracer 찾기`!!!

### MCard가 그냥 DB형인 경우

```python
mcard.delete()
_update_to_confirmed_transaction(related_transaction)
```

- 디비에서 카드 삭제 후, 해당 관련 트랜잭션에 상태 업데이트 후 리턴
- 트랜잭션 주소 locking 걸기

---

## 2. ***Async인 경우***

- `enqueue_mcard_single_burn` 를 호출함으로 해당 테스크를 큐에 넣음

    ```python
    # 메시지 브로커인듯
    publisher = QueuePublisher(name='mcard.single_burn',type='direct') 
    ret = publisher.publish({'mcard_burn':mcard_burn_data},
    request_id=request_id)
    ```

    mcard.single_burn이라는 퍼블리셔가 생김

    **publisher가 큐에 해당 테스크를 넣음**

    → `kombu` 라이브러리를 기반으로 rabbitmq 큐에 원하는 (mcard 버닝이란) 테스크를 퍼블리시 하면, 큐에 mcard_burn이라는 키와 데이터, 리퀘스트 아이디가 인큐됨

    ### Kombu란?

    > 파이썬 메시징 라이브러리
    메시지 브로커를 쉽게 사용할 수 있는 솔루션

    1. 다양한 메시지 브로커를 지원함
    2. 자동으로 인코딩과 정규화를 해줌
    3. 메시지 전송과 관련하여 예외처리가 잘 되어있음
    4. 커넥션이나 채널 오류가 있을 때에도 정상적으로 동작하도록 구현되어있음
    5. amqplib의 불편한점들이 수정됨
    6. carrot을 사용하고 있는 프로젝트를 쉽게 포팅할 수 있음

    - **`rabbitmq` 에서 Exchange란?**
        - Queue에 전송되기 전에 거쳐가는 라우터
        - 어떤 방식으로 메세지를 전달하냐에 따라 type이 나뉨
            1. fanout
                - bind된 모든 큐에 메시지를 전달
            2. direct
                - routing_key를 설정하여 같은 routing_key를 갖은 큐에만 선택적으로 메시지를 전달
            3. topic
                - direct type과 비슷하고 대신 routing_key에 패턴을 설정할 수 있음
                - 패턴에는 * 또는 #을 사용하는데, *은 모든 단어, #은 공백을 포함한 모든 단어
                - 단어의 구분은 .으로 함
            4. header
                - key와 value를 설정하여 선택적으로 메시지를 전달

    **`Producer`**

    - producer가 메시지를 publish하는 순서
    - exchange 선언 → queue 선언 → producer 선언 → publish 메시지 전달
    - publish할 때, declare 옵션에 따라 exchange, queue의 존재 여부를 확인하여 생성을 하거나 에러를 발생할 수 있음
        - rabbitmq에 exchange, queue가 있다면 그대로 사용 가능
        - 존재하는 exchange나 queue라면 바로 사용 가능하다는 뜻인듯
        - 코드상에서는 exchange나 queue 명을 쓰면 바로 그 녀석을 사용할 듯

            QueueMixin을 정의함으로 인해, option값으로 기본 세팅을 맞칠 수있음 → QueueMixin을 사용함으로 인해, 큐의 기본 세팅을 할 수 있음

            아래는 koin_server에서 사용하는 큐 퍼블리셔들임

            ```
            QUEUE_PUBLISHERS = {
                'mcard.mint': _publisher_default_options,
                'mcard.single_burn': _publisher_default_options,
                'mcard.single_mint': _publisher_default_options,
                'mcard.single_transfer': _publisher_default_options,
                'mcard.transfer': _publisher_default_options,
                'transaction.process': _publisher_default_options,
                'transaction.callback_process': _publisher_default_options,
                'mtoken.transfer': _publisher_default_options,
                'mtoken.share': _publisher_default_options,
                'user.process': _publisher_default_options,
                'talk_message.send': _publisher_default_options,
                'mtoken.callback': _publisher_default_options,
                'service.funding': _publisher_default_options,
                'service.bulk_refund': _publisher_default_options,
                'hrdk.process': _publisher_default_options,
            }
            ```

    - Exchange
        - `option` 중 **durable**
            - True로 하면, rabbitmq 서버가 죽어서 재시작하여도 유지됨
            - 디스크를 사용하냐, 메모리를 사용하냐의 차이
    - Queue
        - 위 durable이라는 옵션은 동일
        - **auto_delete**
            - 하나 이상의 소비자가 연결된 후에 모든 소비자가 연결이 끊어지면 큐가 삭제됨
            - rabbitmq에 exchange나 queue가 없을 때에도 자동으로 만들어짐

    `Consumer`

    - exchange
